(1)顺序查找(顾名思义)
应用范围：顺序表或线性链表表示的静态查找表
表内元素无序
平均查找长度(ASL):[累加求和(n-i+1)]/n,i从1到n
即(n+1)/2
时间复杂度:O(n)
空间复杂度:O(1)

(2)本章的数据元素类型定义(统一)
typedef struct{
    KeyType key;
    //其他域
}ElemType;

(3)指针也是数组名
经常会有ElemType *R;    R[i]这种用法

(4)折半查找：每次将待查记录所在区间缩减一半
仅适用于有序的顺序存储结构顺序表(对线性链表无效),以升序顺序表为例：
mid=(high+low)/2
key<mid，则high=mid-1，再mid=(high+low)/2，将key与mid比较
key>mid,则low=mid+1,再mid=(high+low)/2，将key与mid比较
key=mid，就找到了
如果high<low,结束，没找到

性能分析：
可以用一棵二叉树来描述折半查找的过程，称此二叉树为折半查找的二叉树，
每个节点的层次(根节点层次为1)即为查找该结点的次数
n个结点，比较次数不会大于判断树的高度，判断树高度为以2为底n的对数取整再+1
平均查找长度(ASL):以2为底(n+1)的对数-1    (n>50)
时间复杂度：O(logn)

(5)分块查找(索引顺序表查找)
条件:a.将表分成几块，且表或者有序，或者分块有序；
即若i<j，则第j块中所有记录的关键字均大于第i块中的最大关键字
b.建立"索引表"(索引表每个节点含有对应块的最大关键字域和指向本块第一个节点的指针，且按关键字有序)

查找过程：先确定待查记录所在块(利用顺序或折半查找)，再在块内查找(顺序查找)
分块查找的性能介于顺序查找和折半查找之间

(6)动态查找表
在查找过程中，表示动态生成的，有很多，比如二叉排序树、平衡二叉树、红黑树、B-树、B+树、键树...
教材只介绍二叉排序树(BST)和键树

(7)二叉排序树(BST)，又称二叉查找树、二叉搜索树
二叉排序树或是空树，或是满足如下性质的树:
a.若其左子树非空，则左子树上所有结点的值均小于根节点的值
b.若其右子树非空，则右子树上所有结点的值均大于等于根节点的值
c.其左右子树本身又各是一颗二叉排序树
所以，二叉排序树中序遍历结果为升序序列

性能分析：找到某一个值其实就是走了一条从根节点到目标节点的路径，所以比较次数就是节点所在的层次
最多比较次数就是二叉排序树的深度
平均查找长度(ASL)与树的深度有关，事实证明，二叉排序树越平衡，树高度越低，ASL越小，由此引进
平衡二叉树(AVL)，平衡二叉树是查找效率最高的二叉排序树
平衡二叉树特点：每个结点左右子树高度差≤1
以下内容教材没有，为补充:
为了维护或者构建平衡二叉树,可给每个节点再增加一个信息:平衡因子
代表当前节点左子树高度-右子树高度，由平衡二叉树定义可知平衡因子的取值只有-1,0,1，
失衡结点：平衡因子不等于-1,0,1的结点
在插入节点时：
    A:失衡结点，不止一个失衡结点时，为最小失衡子树的根节点
    B:A结点的孩子，B结点的双亲
    C:插入新节点的子树
根据三个结点的相对位置可以将失衡情况分为LL、LR、RL、RR型这四种情况
三个结点对应中序遍历，将中间节点作为根节点，第一个节点作为左孩子，最后一个节点作为右孩子，高度均由三层变为两层
这样调整既降低高度又保持二叉排序树
归纳：调整原则：a.降低高度 b.保持二叉排序树性质
具体怎么调整有兴趣再去了解(王卓第13周2~4)，这里不再阐述


(8)散列表(哈希表)
基本思想:记录的存储位置与关键字之间存在对应关系
对应关系是通过哈希(hash)函数求得的
简单来说，就是根据关键字的值再通过hash函数的运算来得到它的存储地址，即Loc(i)=H(keyi)
这个H具体是怎么对应的是不唯一的
优点:查找效率高     缺点：空间效率低

散列方法(杂凑法)：选取某个函数，依该函数按关键字计算元素的存储位置，并按此存放；
查找时，由同一个函数对给定值k计算地址，将k与地址单元中元素关系码进行对比，确定查找是否成功
散列函数(杂凑函数)：散列方法中使用的转换函数
散列表：按上述思想构造的表

冲突：不同的关键码映射到同一个散列地址，即A存在这，B也存在这，就冲突了
具有相同函数值(其实就是地址)的多个关键字称为同义词
在散列查找方法中，冲突是不可能避免的，只能尽可能减少

使用散列表要解决好两个问题：
问题一：构造好的散列函数
a.所选函数尽可能简单，以便提高转换速度
b.所选函数对关键码计算出的地址，应在散列地址中集中致均匀分布，以减少空间浪费
(什么意思？也就是说地址要比较均匀，太集中在一起会产生很多冲突，太散又浪费空间)
问题二：制定一个好的冲突解决方案

构造散列函数考虑的因素:
a.执行速度(即计算散列函数所需时间)
b.关键字长度
c.散列表的大小
d.关键字的分布情况
e.查找频率

(9)散列函数的构造方法
根据元素集合的特性构造
要求1：n个数据原仅占用n个地址，虽然散列表查找是以空间换时间,但仍希望散列的地址空间尽量小
要求2：无论用什么方法存储，目的都是尽量均匀地存放元素，以避免冲突
方法：
a.直接定址法(教材没有,最简单最理想化的方法):关键字本身，直接作为存储地址（或经简单变换后作为地址）。即以关键字key的某个
线性函数值作为散列地址，不会产生冲突
缺点：要占用连续地址空间，空间效率低
b.除留余数法(最常用、最重要)：
核心公式：H(key)=key mod p
如何选p:表长m，取p<=m且p为质数
c.平方取中法
先将关键字平方，再取平方结果的中间若干位作为散列地址,记作:H(key)=Mid(key²)
d.折叠法
将关键字分成若干位数相同的部分，然后将这些部分相加（或叠加），再取结果作为散列地址。
分为移位叠加和间界叠加
key:185654235765(三位三位的取)
移位叠加：185+654+235+765
间接叠加：185+456+235+567
无论哪种方式，结果和分段的位数相同，即进位高位舍弃

(10)处理冲突的方法
a.开放定址法
基本思想：有冲突时就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将数据元素存入
一般形式：Hi​(key)=(H(key)+di​) mod m
H(key)：初始散列地址    di：第i次探测的增量     m：表长
开放定址法的几种常见形式：
线性探测法（最基础）
二次探测法（平方探测）:di​=0,1²,−1²,2²,−2²,…,一个个加(换着加不是累加)直到找到空位置
伪随机探测法(di随机无规律)
双散列法（再散列法）

b.链地址法(拉链法)
基本思想:相同散列地址的记录链成一单链表
简单来说，就是把挤在同一个地址的同义词串起来，只把表头指针存在这个地址
m个散列地址就设m个单链表,然后用一个数组将m个单链表的表头指针存储起来，形成一个动态结构
链地址法建立散列表步骤：
Step 1：
对数据元素的关键字key计算散列函数值H(key)，得到散列地址i。
Step 2：
若散列地址i对应的链表为空，则将该元素作为该链表的第一个结点插入。
Step 3：
若散列地址i对应的链表非空（即发生冲突）,则将该元素按前插法或后插法插入到该地址对应的同一条链表中。
优点：不易产生聚集现象，同义词仅集中在各自的链表中，不会像线性探测那样产生严重的“聚集”。

(11)散列表的查找
给定k值，计算地址H(k),若此地址为空，查找失败。若此地址存在，看此地址关键字是否==k,若等于，
查找成功，若不等于，就按照处理冲突的方法计算Hi即下一个存储地址，再重复上述步骤

性能分析：ASL取决于散列函数、处理冲突的方法、散列表的装填因子α
α=(表中填入记录数/哈希表的长度)     α其实就是平均每个散列地址上有多少记录
α越大，表中记录数越多，说明表装的越满，发生冲突的可能性就越大，查找时比较次数就越多(同义词链变长/探测次数增加)
关于查找成功和查找不成功时散列表的ASL可见教材p272(与装填因子α有关)

(12)散列表(哈希表)的几点结论：
a.散列表具有很好的平均性能，优于一些传统的技术
b.链地址法优于开放地址法
c.除留余数法作散列函数优于其他类型函数(除留余数法最好)