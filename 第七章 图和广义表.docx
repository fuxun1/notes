(1)图的基本概念
图由顶点和边构成
分为有向图(每条边都有方向)和无向图(每条边都无方向)，是多对多的关系

(2)完全图
任意两个点都有一条边相连
完全图又分有向完全图和无向完全图
无向完全图:n个顶点就有n(n-1)/2条边
有向完全图:n个顶点就有n(n-1)条边，也就是无向完全图的两倍

(3)稀疏图
有向图中的边又可称为弧
所以有很少边或弧的图就叫稀疏图(e<nlogn,n为顶点数目)

(4)稠密图
与稀疏图相反即e>=nlogn

(5)网:边/弧带权的图

(6)邻接:有边/弧相连的两个顶点之间的关系
(a,b)->a,b邻接且不分先后,即无向图
<a,b>->a,b邻接且分先后，称a邻接到b,b邻接于a

(7)关联(依附)
边/弧与顶点之间的关系，若(a,b)/<a,b>，则称该边/弧关联于a和b

(8)顶点的度:与该顶点相关联的边/弧数目，记作TD(v);v是顶点
有向图中顶点的度又分为入度和出度，顶点的度等于二者之和
入度:以当前顶点为终点的弧的数目,记作ID(v)
出度:以当前顶点为始点的弧的数目,记作OD(v)
有向树是一种特殊的图(仅有一个顶点入度为0,其余顶点入度为1)

(9)路径:接续的边构成的顶点序列
路径长度:路径上边或弧的数目/权值之和(有权值算权值，没权值算边/弧的数目)
回路(环)：第一个顶点和最后一个顶点相同的路径
简单路径:序列中顶点都不相同
简单回路：除了第一个顶点和最后一个顶点相同，其余顶点均不相同的回路

(10)连通图(强连通图)
在无向图(有向图)中,若对任何两个顶点v,u均存在从v到u的路径,则称之为连通图(强连通图)

(11)权与网
权：边/弧具有的相关数称为权，表明从一个顶点到另一个顶点的距离或耗费
带权的图称为网

(12)子图(略)
无向图：非连通图中各个连通子图称为该图的连通分量
有向图：非强连通图中各个强连通子图称为该图的强连通分量
极小连通子图：该子图是G的连通子图且在该子图中删除任何一条边该子图不再连通
生成树：包含无向图G的所有顶点的极小连通子图
生成森林：对非连通图，由各个连通分量的生成树的集合

(13)图的存储方式-数组(邻接矩阵)

无向图的邻接矩阵：
一个一维数组存储各个顶点，称为顶点表
一个二维数组(邻接矩阵)存储各个顶点之间的关系(有n个顶点就是n*n的矩阵)
邻接矩阵A.arcs[i][j]，值为1代表存在<i,j>或者(i,j)，值为0则不存在
无向图的邻接矩阵的特性：
a.对角线元素为0
b.邻接矩阵一定是对称矩阵
c.顶点i的度=第i行(列)中1的个数
d.完全图的邻接矩阵只有对角线元素为0

有向图的邻接矩阵：
依旧n*n(n为顶点个数)
有向图的邻接矩阵的特性：
a.不一定是对称矩阵
b.第i行为出度边，即Vi为始点;第i列为入度边，即Vi为终点
c.由b易知，顶点Vi的出度为第i行元素之和；顶点Vi的入度为第i列元素之和
所以顶点Vi的度为入度与出度之和<==>第i行与第i列元素之和

有向网的邻接矩阵:
A.arcs[i][j]的值为Wij(权值)和∞(无边/弧)
其余性质和有向图邻接矩阵类似(入度出度不再是求和，而是看不为∞的元素个数)

(14)指针用箭头,S->成员
不是指针使用成员就用'.',L.成员

(15)利用邻接矩阵构造无向网(网的边是有权值的)
算法思想：a.输入总顶点数和总边数
b.依次输入点的信息存入顶点表
c.初始化邻接矩阵，使每个权值初始化为极大值(即默认边都没权值)
d.构造邻接矩阵

若构造无向图，则初始化邻接矩阵的权值均为0，输入的时候w为1，只用改动这两处

若构造有向网，只需改动一处，即不用给对称边G.arcs[j][i]赋值

若构造有向图，则则初始化邻接矩阵的权值均为0，输入的时候w为1，且不用给对称边G.arcs[j][i]赋值
即综合无向图和有向网的改动即可

(16)邻接矩阵优缺点
优点：
简单直观好理解
方便查看任一顶点的所有邻接点
方便计算任一顶点的入度、出度和度(无向图的度直接行(列)非零元素相加即可，有向图分行(出度)和列(入度)，二者相加为度)
缺点：
不便于增删顶点
浪费空间->存稀疏图(点多边少)有大量无效元素
浪费时间->统计稀疏图中一共有多少条边，需要对邻接矩阵所有元素都遍历一遍

(17)无向图邻接表(其实就是指针数组,指针指向线性链表)
依旧一个一维数组存放所有顶点，但是每个元素又是一个线性链表，
对于每个元素，头结点存放顶点的值以及第一条弧的指针，后续节点(边结点)存放邻接点的序号和指向下一个边结点的指针
如果不是图而是网，那就还需要给边结点增加一个成员->权值
邻接表不唯一，边的顺序可变
若无向图有n个结点e条边，则邻接表需要n个头结点和2e个边结点
邻接表适用于存储稀疏图
无向图某个节点的度就是边结点的数目

(18)有向图邻接表
有几条边就有几个边结点，所以需要的空间是n+e,即顶点数+边结点数
找出度容易找入度复杂，Vi顶点的出度为第i个顶点的边结点数目
而Vi顶点的入度是整个邻接表中域值为i-1(第i个顶点下标为i-1)的边结点数目
为了找入队,有向图邻接表还有另一种存储方式，即存储每个顶点的入度边，称为逆邻接表
这样，顶点Vi的入度边为第i个顶点的边结点数目，出度为整个邻接表中阈值为i-1的边结点个数

(19)typedef
彻底弄懂typedef
typedef int a <==>typedef struct{...} a
所以struct结构体只是一个数据类型，大括号外面起的是名字，当然还可以定义为指针或数组
typedef int arr[10] <==> typedef struct{...} arr[10] -->由10个struct{...}类型构成的数组
还可以再前面起个别名，typedef struct{...}Node,Nodelist[10],表示存储10个Node的数组,一个Node又是一个struct{}

(20)图的遍历
要从连通图中某一顶点出发，沿着一些边访遍图中所有顶点，且使每个顶点仅被访问一次，叫做图的遍历
遍历的实质：其实就是找每个顶点的邻接点的过程
为了避免重复访问，设置辅助数组visited[n],初始visited[i]为0，顶点i被访问，改visited[i]为1，防止重复访问
常用两种遍历方式:深度优先搜索(DFS)和广度优先搜索(BFS)
深度优先：
通俗来说就是一条道走到底，无路可走就回退(原路返回)，直到找到可走的路继续一路走到底，走不了就回退...直到最后回退到起始点
遍历完成
注意，每次选取邻接点是任意的，所以，深度优先遍历次序不唯一，
但是，无向图遍历中，如果邻接矩阵定了，那深度优先遍历次序也就定了
广度优先：
先访问起始顶点的所有邻接点，再访问每个邻接点的所有未被访问过的邻接点...,直至所有顶点均被访问
一圈一圈一层一层的扩大，很像树的层次遍历

(21)生成树：一种特殊的无向图/无向网，包含图的所有顶点
所有顶点均由边连接在一起但不存在回路的无向图、网
因此易知生成树是图的极小连通子图，去掉一条边就非连通
所以，有n个顶点的连通图的生成树一定有n-1条边
生成树分为深度优先生成树和广度优先生成树，生成树其实也是找无向图的极小连通子图的过程

(22)最小生成树
给定一个无向网，在该网的所有生成树中，使得各边权值之和最小的那棵生成树称为该网的最小生成树，
也叫最小代价生成树，最小生成树不一定唯一
应用场景:城市间电网等等(每个顶点都要经过，还要花费最少即边权值之和最小)

构造最小生成树--普里姆算法->适合稠密图
将无向网的顶点分为U和V-U两部分，U初始为空，选一个起始点存入U,然后再U和V-U之间选一条最小权值路径，
把点连起来,把边(u,v)存入边集合，把路径连接的V-U中的点存入U，U扩充，V-U减少，继续再U和V-U之间
选一条权值最短路径，把边(u,v)存入边集合并将路径连接的V-U中的点存入U...，
不断重复直至U中的顶点数为无向网的所有顶点数，最小生成树生成完毕
上述算法思想依据MST性质且类似于贪心算法，不断选取局部最优解得到全局最优解
时间复杂度O(n²)  n:顶点数      选点

构造最小生成树--克鲁斯卡尔算法->适合稀疏图
也是贪心算法而且特别贪心
令最小生成树初始状态为只有n个顶点而一条边都没有(相当于把边全部去除)，顶点相对位置不变
可以把边按权值升序存入边集合，每次从边中选一个权值最小的边把对应点连起来，即从边集合中从左到右
一个个选，但是需注意不能形成回路，如形成回路，跳过该边，继续从下一条边开始...
直至选出n-1条边为止(n个顶点的最小生成树有n-1条边)
时间复杂度:eloge  e:边数    选边

两种算法代码实现不需要掌握，主要了解思想，会画生成树的过程

(23)单源最短路径
从指定出发点出发，到其余顶点的最短路径(权值之和最小，而不是说边数最少)
解决此类单源最短路径问题有一个经典算法==>迪杰斯特拉算法

迪杰斯特拉(Dijkstra)算法：      (重点)
初始状态：S集合:{V0}(代表已找到最短距离的顶点集合)  T集合{其余顶点}   i记录走几次，为横表头，V1~Vn为竖表头
类似于(无法到达记为∞)：

终点   从v0到各终点的最短路径
       i=1 i=2 i=3 i=4 i=5...
v1      x   x   x   x   x
v2      x   x   x   x   x
v3      x   x   x   x   x
v4      x   x   x   x   x
...     ... ... ...  ...  ...
vn      x   x   x   x   x
Vj
距离

i=1时，记录只走一步v0到达各个顶点的距离，相当于找v0到邻接点的距离，然后从这一列中找最小的距离值
作为当前最短路径的顶点，记录在Vj，并把该顶点加入S，这个最小距离记在"距离"这一行。
假设v0到v2距离最小，那么v2记录在Vj，S={v0,v2}
i=2时，继续，即在v2的加入下,v0经过v2到各顶点的距离有没有减少,如果经过v2到不了就延用前一列的值；
v2不用再看了，已经找到最短路径。如果v0经过v2到达其他顶点的距离变短，就将距离值更新为这个更短的值
这一轮结束后，依旧选一个距离最小值，并将对应顶点存入S，同理该顶点不用再看
i=3时，依次类推，有了前两个顶点的加入，从v0到各个顶点(不算已经找到的)的距离需不需要更新，再选一个最小
的距离值并将对应顶点存入S
...
直至S=V(所有顶点的集合)
思想:每轮找的是最小值最短距离，从邻接点开始，那么后面无论哪一轮选中的最小值就一定是v0到该顶点的最小值，
因为到该顶点的前面的路径都是一轮一轮挑出来的最小值，那最终肯定就是最短距离，类似于贪心算法，由局部最优解
找到全局最优解
时间复杂度：O(n²)

(25)所有顶点间最短路径(了解)(教材没有)：
方法一：
以每个顶点为源点，对每个顶点执行Dijkstra算法,n个顶点执行n次
时间复杂度：O(n³)，即O(n*n²)
方法二：经典算法==>弗洛伊德(Floyd)算法
算法描述：
a.初始n阶矩阵(其实就是邻接矩阵)
b.然后不断更新这个矩阵:
每次再原直接路径中增加新的中间顶点，比如BA,增加C变成BCA,如果<B,C>+<C,A>小于<B,A>
那就更新<B,A>位置的权为<B<C>+<C,A>
而增加新中间顶点A或者B，<B,A>是不变的，不用管，一行一行的看，一行代表这一行的那个顶点到各个顶点的权值
增加不是乱增，而要有一定顺序，比如A,B,C三个顶点的图，矩阵得到了之后，第一轮先增加中间顶点A,替换完之后，
第二轮再增加中间顶点B,替换完之后，第三轮再增加中间节点C...直至所有顶点均被作为中间顶点增加一次。
注：每一轮增加顶点要代入所有顶点间路径,比如3*3矩阵就是9个路径(从一个顶点到另一个顶点)都要代入看权值是否需要替换
最后得到的矩阵就是顶点间最短路径的矩阵

(26)有向无环图==>顾名思义即可
有向无环图的两种表示方法：
AOV网：用一个有向图表示一个工程的各个子工程及其相互制约的关系，其中，以顶点表示活动，
弧表示活动之间的优先制约关系，称这种有向图为顶点表示活动的网，简称AOV网或活动顶点网络。
应用AOV网解决拓扑排序问题

AOE网：用一个有向图表示一个工程的各个子工程及其相互制约的关系，其中，以弧表示活动，
顶点表示活动的开始或结束事件，称这种有向图为边表示活动的网，简称AOE网或活动边网络。
应用AOE网解决关键路径问题

(27)拓扑排序
若从i到j有路径，则称i是j的前驱，j是i的后继
若<i,j>是网中有向边，则i是j的直接前驱，j是i的直接后继
在现实中，易知AOV网不可能出现回路，那如何判断AOV网有没有回路呢?
排课问题，有些课是另一些课的先行课，怎么排课?
解决上述两类问题都需要拓扑排序
什么是拓扑排序：
    在AOV网没有回路的前提下，将全部活动排成一个线性序列，使得AOV网中有弧<i,j>存在，
    则在这个序列中i一定在j前面(不一定是直接前驱但必须是前驱)，具有这种性质的线性序列称为拓扑有序序列，
    相应的拓扑有序排序的算法称为拓扑排序
    所以，将一个AOV网的所有顶点排成拓扑有序序列的过程的算法称为拓扑排序

拓扑排序的方法：
a.在有向图中选取一个没有前驱的节点并且输出
b.从图中删除该顶点和从它出发指向其他顶点的弧
c.重复上述两步，直至全部顶点均已输出或者图中不存在无前驱的节点为止(删完了或者没有可删的为止)
这样输出的线性序列不唯一但一定是拓扑有序序列，因为是任选一个无前驱的节点输出，所以不唯一
因为每次选的是无前驱的节点，无前驱分为该节点本来就没有和它的前驱被输出然后删除两种情况，前者不用说，显而易见，
后者一定是前驱被输出然后删除之后它才变为无前驱，输出它的时候没有任何结点指向它，所以输出它的时候它的前驱
一定已经被输出了。"输出我时我都没有前驱你不能说我在前驱之前输出吧"

检测AOV网中是否存在回路的方法：
    对网构造拓扑有序序列，如果有序序列中包含图的所有顶点，那该图就一定不存在回路
    因为回路的每个顶点都有前驱且无法输出和删除

(28)关键路径
在AOE网中，关键路径是从源点到汇点路径长度最大的路径，其长度等于工程的最短完成时间。
听起来可能有点矛盾，其实并不矛盾，工程是可以并行进行的，整个工程的完工必须是所有工程都完工，
完工指从起点到汇点花的时间，所以路径长度最大的路径花费时间最长，只有这条路径到达汇点才说整个工程完工，
所以关键路径长度也等于工程最短完成时间。
比如，工程有两条路径，A路径5天完成，B路径10天完成，那么整个工程的最短完成时间就是10天，
其中A路径可以灵活选取，比如前面5天，最后5天或者中间5天都行，但是并不影响整个工程的最短完成时间还是10天，
因为路径B也必须完成
也就是说最好在趁着完成耗时久的工程时把耗时短的也趁机做了，这样工程完成最快，就是关键路径的长度

确定关键路径，需要定义四个描述量:
a. ve(vj):表示事件vj的最早发生时间
b. vl(vj):表示事件vj的最晚发生时间
c. e(i):表示活动i的最早开始时间
d. l(i):表示活动i的最晚开始时间
l(i)-e(i)表示完成活动i的时间余量，即中间这段时间活动i什么时候开始都行
而关键路径上的活动是没有时间余量的，即l(i)==e(i),这些活动的最早开始时间等于最迟开始时间，
其中任何一个活动的延误都会导致整个工程延期。
l(i)==e(i)表示i是关键活动，关键活动找到了关键路径就找到了，所以找关键路径就是找出所有满足l(i)==e(i)的关键活动

带v的表示顶点,e为early,l为late
顶点是事件，路径(弧)才是活动，假设两个顶点j和k,弧上活动为ai，其持续时间记为Wj,k即j————>k,那么
e(i)=ve(j)  //活动ai的最早发生时间=事件j的最早发生时间
l(i)=ve(k)-Wj,k //活动ai的最晚发生时间为事件k的最晚发生时间减去弧的权值(即活动ai耗费的时间)
比如总时间100分钟,事件k最晚发生时间为第80分钟，活动ai耗时20分钟，那么ai最晚发生时间为第60分钟
如何求ve(j)和vl(j)(核心：保证最长/慢的能够做完，这是顶点跃迁的前提):
    从ve(1)=0开始向后推(顺推)，ve(j)=Max{ve(i)+Wi,j},<i,j>∈T,j∈[2,n]    T为弧集合
    因为事件发生代表前面与它相连的活动都完成，所以选最大的，再早最长的活动就做不完了
    从vl(n)=ve(n)开始逆推,vl(i)=Min{vl(j)-Wi,j}     整体最小即Wi,j最大，因为从i到j要保证所有都做完，
    也就是最长的也得做完，减去那个最长的就是最晚发生时间，再晚长的就做不完了，即起码要预留足够做完最长的的时间

所以，a.先利用ve(j)=Max{ve(i)+Wi,j},vl(i)=Min{vl(j)-Wi,j}找出所有事件的最早和最迟发生时间:ve(j)和vl(i),
b.再利用e(i)=ve(j),l(i)=ve(k)-Wj,k找到所有活动的最早和最晚开始时间e(i)和l(i)，
c.再找出所有满足l(i)==e(i)的关键活动,由关键活动构成关键路径
具体实例可反复观看b站王卓这一节知识(24min25s开始)
结论：a.若网中有几条关键路径，则需加快同时在几条关键路径上的关键活动
b.若一个关键活动处于所有的关键路径上，那么提高这个活动的速度就能缩短整个工程的完成时间
c.处于所有关键路径上的关键活动的完成时间不能缩短太多，否则会使原来的关键路径不再是关键路径

(29)广义表(Lists)
广义表是n>=0个元素的有限序列a0,a1,...,an-1,其中每一个ai或者是原子或者是一个广义表
广义表表示：LS=(a1,a2,...,an),LS为表名,n为表的长度，。每一个ai为表的元素
习惯上用大写字母表示广义表，小写字母表示原子
表头：第一个元素a1
表尾：除了表头之外其他元素组成的表，表尾不是最后一个元素，而是一个子表
eg:C=(a,(b,c))为一个广义表，长度为2，由原子a和子表(b,c)构成，表头为a，表尾为((b,c)) ,加一个括号，因为
"表尾是除了表头之外其他元素组成的表"，组成表所以加括号，即表尾是广义表，里面只有一个元素(b,c)

广义表的性质：
a.广义表中的数据元素有相对次序:一个直接前驱和一个直接后继
b.广义表的长度定义为最外层所包含的元素个数
c.广义表的深度定义为该广义表展开后所含括号的重数    (a,(b,(c,d)),c)的深度为3，( )的深度为1
d.广义表可以是一个递归的表，如F=(a,F)<==>F=(a,(a,(a,(a,...))))
递归表的深度是无穷值，长度是有限值
广义表是线性表的推广，线性表是一种特殊的广义表
当二维数组的每行(每列)作为子表处理时，二维数组即为一个广义表

广义表的基本运算：
GetHead(L)求表头、GetTail(L)求表尾
广义表通常用链式存储结构




