2025.12.12
(1)树和二叉树之间的转换
树和二叉树之间的转换可以二叉链表作媒介
树->二叉树：右兄弟变右孩子
二叉树->树：右孩子变右兄弟
给定一棵树，可以找到唯一的二叉树与之对应
将树转化为二叉树：
理论转换方式(底层原理):先把树存储为孩子兄弟链表，然后将树的孩子兄弟链表解释为二叉链表，
再由二叉链表得到对应的二叉树
但是这样太麻烦了，有更简单的方法：
1.加线:兄弟之间连线
2.抹线:对每个节点，除了与左孩子之间的连线保留，其余与孩子之间的连线去除
3.旋转:绕着每一个根节点(原树的根节点和每一个最左边的孩子)顺时针旋转45°(其实就是右兄弟变为右孩子)
将二叉树转换为树:
1.加线:若p结点是双亲结点的左孩子,则将p的右孩子,p的右孩子的右孩子...一直找下去全部和p的双亲连起来(超级加辈)
沿着右下角一直找下去在树中本质就是一个兄弟链表(因为树的右指针指向兄弟而非右孩子)
2.抹线:抹除原二叉树中双亲与右孩子之间的连线
3.调整:将结点按层次排列，形成树结构(可理解为绕着每一个左孩子逆时针旋转45°)

(2)森林与二叉树之间的转换
1.森林转二叉树:
第一步:将各棵树分别转化成二叉树
第二步:将每棵树的根节点用线相连
第三步:以第一棵树的根节点为整个二叉树的根节点,再将其他树的根节点绕整个二叉树根节点顺时针旋转45°,构成二叉树结构
2.二叉树转森林:
第一步:抹线:从根节点开始，沿着右分支一直寻找下去(右孩子，右孩子的右孩子...),将根节点以及这些结点之间的线
全部抹除,使之变成孤立的二叉树
第二步:将孤立的二叉树按照二叉树转换为树的方法还原为树,这样就还原为了森林

(3)树的遍历
分三种:先根遍历，后根遍历，层次遍历(树没有中序遍历)
与二叉树类似，这个不难，就不详细写了

(4)森林的遍历
将森林分为三个部分:1.森林中第一棵树的根节点 2.森林中第一棵树的子树森林 3.森林中其他树构成的森林
按照这三个部分的遍历顺序分为:先序遍历(123),中序遍历(213)
(重要)森林先序遍历其实就是从左至右依次对每棵树先根遍历
森林中序遍历其实就是从左至右依次对每棵树后根遍历
简单来说，先根遍历:从上往下，从左至右       中序遍历：从下往上，从左至右

(5)哈夫曼树
哈夫曼树也叫最优二叉树(b站课程是通过引入成绩分等级寻找最少比较次数引入)
寻找这样的一种二叉树也可以理解为寻找树带权路径长度之和最短的二叉树
路径:一个节点到另一个节点的分支构成这两个结点之间的路径
结点的路径长度:两节点间路径上的分支数
树的路径长度:树的根节点到每个节点的路径长度之和,记作TL
结点数目相同的二叉树中，完全二叉树的路径长度最短
但是路径长度最短的二叉树不一定是完全二叉树(比如最后一层最左边的叶子结点其实可以在这一层平移,路径长度都一样短)
权：将树中结点赋给一个有着某种意义的数值，则这个数值称为该结点的权
结点的带权路径长度:从根节点(一定是从根节点)到该结点之间的路径长度与该结点的权的乘积
树的带权路径长度(WPL):树当中的所有叶子结点的带权路径长度之和
所以哈夫曼树就是带权路径长度(WPL)最短的二叉树(这里是在度相同的二叉树中比较)
满二叉树不一定是哈夫曼树而且易知在哈夫曼树中权值越大的叶子节点离根越近

(6)贪心算法
贪心算法之构造哈夫曼树:构造哈夫曼树时首先选择权值小的叶子结点
贪心算法是一类算法的统称，构造哈夫曼树只是其中一个应用场景
贪心算法通用策略:每一步都选择当前看来最优的局部选择,期望得到全局最优解
常见的贪心算法包括：
哈夫曼编码（每次选最小的两个权值合并）
最小生成树（Prim、Kruskal）
活动安排问题（选结束最早的活动）
Dijkstra 最短路径（每次扩展距离最小的节点）
区间调度
找硬币（最少硬币找零，贪心币制下）

(6)构造哈夫曼树
使用贪心算法的思想，具体步骤:
第一步:根据n个给定的权值,构造含有n棵二叉树的森林,每棵二叉树其实就一个根节点(相当于把n个结点排成一排)
第二步:选取其中两个根节点权值最小的二叉树(作为左右子树)构成一颗新二叉树，且根节点为左右子树根节点权值之和
第三步:删除那两棵二叉树并把新得到的二叉树添加到森林里
最后:重复第二步和第三步，直到森林中只剩一颗二叉树，这便是哈夫曼树
把上述步骤整理为口诀:构造森林全是根，选用两小造新树，删除两小添新树，重复23剩单根
注意:哈夫曼树的节点的度为0或2,没有度为1的节点。n个带权结点会合并n-1次,也就会产生n-1个新节点
所以,包含n个叶子节点的二叉树的总结点数为2n-1

(7)哈夫曼编码
前缀码：长度不等的编码,任一字符的编码都不是另一个字符的前缀,这样的编码称为前缀码
哈夫曼编码：
a.统计每个字符在电文中出现的频数(频数越大,要求编码越短)
b.将频数作为该字符的权值,利用哈夫曼树的特点,权越大的叶子离根越近,构造哈夫曼树
c.在哈夫曼树的每个分支上标0或者1,结点的左分支标0,右分支标1,把从根节点到叶子结点上分支组成的编码作为该叶子结点
代表的字符的编码

哈夫曼编码能保证一定是前缀编码,因为都是叶子结点,没有一个叶子结点是另一个叶子结点的双亲
哈夫曼树的带权路径长度(WPL)最短,故字符编码的总长最短
因为：权值*路径长度<==>字符出现次数*字符编码长度<==>编码总长
其实，取频率作权值也行，只是上述等价关系不再成立，但不影响结论，因为只是整体的放缩，仍是最优解
其实权值就是出现次数,路径长度就是编码长度

所以,哈夫曼编码是前缀码而且是最优前缀码

(8)哈夫曼编码的算法实现
需要三个存储结构：
a.存储哈夫曼树的结构数组(n个权值则数组大小为2n，1~2n-1存节点)
b.存储每个字符的编码的字符串数组(n个字符则需要n+1大小的空间,0号位置不存)
c.在寻找每个字符的编码的时候需要一个辅助数组来存储编码，数组大小为n(因为n个权值构成的二叉树层数最多为n-1(不算根节点))
最后n-1位置存\0字符串结束符
算法思想：
从根节点开始往下找不好找，所以从叶子结点开始往上找,找到它的双亲,然后看双亲的lch还是rch对应原来结点,
分别标记为0或1，然后再把双亲作为原结点,找它的双亲，看双亲lch还是rch对应原结点...
不断重复一直往上直到双亲为0，说明已经到根节点了,每次得到的0或1存入辅助数组(从后往前存),最后再把辅助数组
得到的编码存入字符串数组
n个权值(即n个字符),外层循环n次，即每个字符都找一趟-->for(int i=1;i<=n;++i)
再一趟中的循环终止条件是双亲为0,即内层循环-->while(f!=0),f代表当前节点的双亲
具体代码后续感兴趣可以学

(9)堆排序
无论大顶堆还是小顶堆，都必须是完全二叉树,一般用数组存储,为方便起见下标从1开始存储,
下标为i的节点的父节点的下标为i/2
下标为i的节点的左孩子的下标为2*i,右孩子下标为2*i+1
最后一个非叶子结点下标位置:length/2

(10)二叉排序树(BST)
性质：对每一个节点，只要左孩子存在，则左孩子小于双亲，只要右孩子存在，则右孩子大于或等于双亲
二叉排序树的左右子树仍为二叉排序树
对排序二叉树进行中序遍历得到的是一个升序的有序序列